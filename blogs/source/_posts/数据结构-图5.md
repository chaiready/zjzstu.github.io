---
title: 数据结构-图5
abbrlink: 95d609b4
date: 2019-08-18 10:48:26
categories:
tags:
---

参考：《大话数据结构》第7章 图

学习路径如下：

1. 图的基本定义
2. 顶点/边/图的关系
3. 图的存储结构
4. 深度/广度优先遍历
5. 最小生成树（*本文学习内容*）

## 最小生成树

参考：[数据结构-图2](https://www.zhujian.tech/posts/a1a1ab33.html#more)

* 最小生成树

>给定无向图$G=(V,E)$，$(u,v)$代表连接顶点$u$和$v$的边，$w(u,v)$代表此边的权重，如果存在生成树$T$使得$w(T)$最小（*权值之和最小*），那么称$T$为最小生成树(`MST, Minimum Spanning Tree`)   

有两种方式常用于最小生成树的创建，一是普里姆（prim）算法，二是克鲁斯卡尔（kruscal）算法

## 普里姆算法

>假设$N=(V,E)$是连通网，$TE$是$N$上最小生成树中边的集合。算法从$T=(U, TE), U={u_{0}}(u_{0}\in V), TE=\{\}$开始。重复执行下述操作：在所有$u\in U, v\in (V-U)$的边$(u,v)\in E$中找一条代价最小的边$(u_{0},v_{0})$并入集合$TE$，同时$v_{0}$并入$U$，直至$U=V$为止。此时$TE$中必有$n-1$条边，则$T=(V,TE)$为$N$的最小生成树

* 因为最小生成树包含连通网所有的顶点，所以从哪个顶点开始都可以

`Prim`算法对顶点进行展开，每次添加一个顶点到`MST`，难点在于如何找到符合条件的顶点：

* 可以设置一个权值数组`lowcost`，设置一个坐标数组`adjvex`，长度均为顶点大小。`adjvex`的下标表示一个顶点，其坐标值表示另一个顶点，即所连接的权值最小边的另一个顶点，`lowcost`保存相应的权值
* 初始化时可以随机选择一个顶点加入`MST`（通常选`顶点0`），然后将其邻接顶点及其权值加入`adjvex`和`lowcost`中
* 每一轮都从`lowcost`中选择一个最小权值边，将邻接顶点加入`MST`，同时搜索其连接的符合条件的边，如果权值小于`lowcost`，则添加到`adjvex`

### c++实现

分别使用邻接矩阵和邻接表实现普里姆算法

#### 邻接矩阵

```
void Undigraph::MiniSpanTree_Prim(MGraph G) {
    int min, i, j, k;
    std::array<int, MAXVEX> adjvex = {};
    std::array<int, MAXVEX> lowcost = {};

    // 默认添加顶点0到MST
    // adjvex赋值为边的另一个顶点值， 如果顶点已在MST中，指定下标赋值为-1
    adjvex[0] = 0;
    lowcost[0] = -1;
    for (i = 1; i < G.numVertexes; i++) {
        lowcost[i] = G.arcs[0][i];
        adjvex[i] = 0;
    }

//    int index = 0;
    // 遍历n-1轮，得到另外的顶点
    for (i = 1; i < G.numVertexes; i++) {
        min = GINFINITY;
        // 遍历n-1次，搜索最小权值边
        j = 1, k = 0;
        while (j < G.numVertexes) {
            if (lowcost[j] != -1 and lowcost[j] < min) {
                min = lowcost[j];
                k = j;
            }
            j++;
        }

        // 输出最小权值边
        printf("(%d, %d)", adjvex[k], k);
//        arrs[index][0] = adjvex[k];
//        arrs[index][1] = k;
//        index++;
        // 顶点k已加入MST，lowcost赋值为-1
        lowcost[k] = -1;

        // 比较顶点k的边集和MST的最小权值边集
        for (j = 1; j < G.numVertexes; j++) {
            if (k != j and lowcost[j] != -1 and G.arcs[k][j] < lowcost[j]) {
                lowcost[j] = G.arcs[k][j];
                adjvex[j] = k;
            }
        }
    }
}
```

## 克鲁斯卡尔算法

>假设$N=(V,E)$是连通网，则令最小生成树的初始状态为只有$n$个顶点而无边的非连通图$T=(V,\{\})$，图中每个顶点自成一个连通分量。在$E$中选择代价最小的边，若该边依附的顶点若在$T$中的不同分量上，则将此边加入到$T$中，否则舍去此边而选择下一条代价最小的边。依次类推，直至$T$中所有顶点都在同一个连通分量上为止。

* 每次选择一条顶点位于不同分量上的边，经过$n-1$次即可连接$n$个顶点
* 首先对边集按权重值进行排序，再升序搜索符合条件的边以及顶点

### c++实现

分别使用邻接矩阵和邻接表实现克鲁斯卡尔算法

#### 邻接矩阵

```
// 权值边存储结构
typedef struct {
    int begin;
    int end;
    int weight;
} Edge;

void Undigraph::MiniSpanTree_Kruskal(MGraph G) {
    int i, j, k, n, m;
    std::array<Edge, MAXEDGE> edges = {};
    // 保存最小生成树，数组下标表示一个顶点，赋值表示另一个顶点
    int parent[MAXVEX];

    // 将边集赋值给edges
    k = 0;
    for (i = 0; i < G.numVertexes; i++) {
        for (j = i + 1; j < G.numVertexes; j++) {
            if (G.arcs[i][j] != GINFINITY) {
                Edge edge;
                edge.begin = i;
                edge.end = j;
                edge.weight = G.arcs[i][j];

                edges[k] = edge;
                k++;
            }
        }
    }
    // 按权值升序排序
    std::sort(edges.begin(), edges.begin() + G.numEdges, less_second);
//    for (i = 0; i < G.numEdges; i++) {
//        printf("(%d, %d) %d\n", edges[i].begin, edges[i].end, edges[i].weight);
//    }

    // 初始化
    for (i = 0; i < G.numVertexes; i++) {
        parent[i] = 0;
    }
    // 升序遍历
    for (i = 0; i < G.numEdges; i++) {
        n = Find(parent, edges[i].begin);
        m = Find(parent, edges[i].end);
        // 判断两个分量是否同属一个
        if (n != m) {
            parent[n] = m;
            printf("(%d, %d) %d\n", edges[i].begin, edges[i].end, edges[i].weight);
        }
    }
}

bool Undigraph::less_second(Edge x, Edge y) {
    return x.weight < y.weight;
}

int Undigraph::Find(int *parent, int f) {
    // 遍历分量
    while (parent[f] > 0) {
        f = parent[f];
    }

    return f;
}
```

## 小结

* 普里姆算法针对顶点进行展开，对于稠密图而言效率更高
* 克鲁斯卡尔算法针对边进行展开，对于稀疏图而言效率更高