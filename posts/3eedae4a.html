<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="alternate" href="/./atom.xml" title="做一个幸福的人" type="application/atom+xml"><meta name="google-site-verification" content="Qr_3yqLtyErDFKHW7mE8PJz4qDUX-bf_fMLpSRckQe4"><meta name="baidu-site-verification" content="zOwIvKMV7f"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.5.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"搜索文章",hits_empty:"我们没有找到任何搜索结果: ${query}",hits_stats:"找到约${hits}条结果（用时${time}ms）"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet"><meta name="description" content="之前在数据结构-图5中实现了图的最小生成树，主要参考的是《大话数据结构》中的相关内容。在Kruskal算法实现中通过函数Find就能检查两个分量之间是否相连，效率很高，当时觉得这种实现很神奇，今天才发现这是一种专门的数据结构实现 - 并查集（disjoint set）"><meta name="keywords" content="c++,并查集,kruskal,邻接矩阵,邻接表"><meta property="og:type" content="article"><meta property="og:title" content="[数据结构][图算法]并查集"><meta property="og:url" content="https:&#x2F;&#x2F;www.zhujian.tech&#x2F;posts&#x2F;3eedae4a.html"><meta property="og:site_name" content="做一个幸福的人"><meta property="og:description" content="之前在数据结构-图5中实现了图的最小生成树，主要参考的是《大话数据结构》中的相关内容。在Kruskal算法实现中通过函数Find就能检查两个分量之间是否相连，效率很高，当时觉得这种实现很神奇，今天才发现这是一种专门的数据结构实现 - 并查集（disjoint set）"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2020-02-15T05:36:35.875Z"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.zhujian.tech/posts/3eedae4a.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>[数据结构][图算法]并查集 | 做一个幸福的人</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?e677aac1ac69b8826b9cfecb4e72e107";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">做一个幸福的人</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">面朝大海，春暖花开</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签<span class="badge">129</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类<span class="badge">48</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档<span class="badge">169</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header> <a href="https://github.com/zjZSTU" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zhujian.tech/posts/3eedae4a.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="zhujian"><meta itemprop="description" content="one bite at a time"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="做一个幸福的人"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> [数据结构][图算法]并查集</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-31 16:11:44" itemprop="dateCreated datePublished" datetime="2019-10-31T16:11:44+00:00">2019-10-31</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-02-15 05:36:35" itemprop="dateModified" datetime="2020-02-15T05:36:35+00:00">2020-02-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/programming-language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/data-structure/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/data-structure/graph/" itemprop="url" rel="index"><span itemprop="name">图</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/data-structure/tree/" itemprop="url" rel="index"><span itemprop="name">树</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/data-structure/graph/minimum-spanning-tree/" itemprop="url" rel="index"><span itemprop="name">最小生成树</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.9k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>之前在<a href="https://www.zhujian.tech/posts/95d609b4.html">数据结构-图5</a>中实现了图的最小生成树，主要参考的是<code>《大话数据结构》</code>中的相关内容。在<code>Kruskal</code>算法实现中通过函数<code>Find</code>就能检查两个分量之间是否相连，效率很高，当时觉得这种实现很神奇，今天才发现这是一种专门的数据结构实现 - 并查集（<code>disjoint set</code>）</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>参考：</p><p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="noopener">Disjoint-set data structure</a></p><p>并查集（<code>disjoint set</code>，也称为<code>union-find set</code>或<code>merge-find set</code>）是一个元素集合，保存了划分为若干个不相交（不重叠）的元素子集</p><p>并查集的操作效率接近常量时间，其操作包括</p><ul><li>添加新的集合</li><li>合并现有的集合</li><li>确定元素是否在同一集合中</li></ul><p>从树结构的角度看，并查集就是一个森林，每个子集就是一颗树</p><p>在图最小生成树的<code>Kruskal</code>算法实现中，并查集起着关键作用</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>并查集中每个元素包含了两个成员：一是元素<code>ID</code>，二是父指针</p><p>利用一个一维数组表示元素集，数组下标表示每个元素，数组值表示父指针</p><ul><li>最开始的数组值可以置为空（<em>或者赋值为当前下标值</em>），表示自己就是根节点</li><li>比较两个元素是否在同一集合中，可以通过函数<code>Find</code>遍历指针，直到根节点。如果两个元素所在的树的根节点相同，表示在同一集合中</li><li>合并两个元素时，首先判断是否在同一集合中，如果不再，则将其中一个根节点置为另一个根节点的孩子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void MiniSpanTree_Kruskal(GraphAdjList G) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 并查集，数组下标表示顶点，赋值表示父节点下标</span><br><span class="line">    int parent[MAXVEX] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    // 升序遍历</span><br><span class="line">    for (i = 0; i &lt; G.numEdges; i++) &#123;</span><br><span class="line">        n = Find(parent, edges[i].begin);</span><br><span class="line">        m = Find(parent, edges[i].end);</span><br><span class="line">        // 判断两个分量是否同属一个</span><br><span class="line">        if (n != m) &#123;</span><br><span class="line">            parent[n] = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int *parent, int f) &#123;</span><br><span class="line">    // 遍历分量</span><br><span class="line">    while (parent[f] &gt; 0) &#123;</span><br><span class="line">        f = parent[f];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找优化"><a href="#查找优化" class="headerlink" title="查找优化"></a>查找优化</h2><p>针对并查集中查找元素根节点函数<code>Find</code>有<code>2</code>种优化方式：</p><ol><li>路径压缩（<code>path compression</code>）</li><li>路径减半（<code>path halving</code>）</li></ol><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>其实现方式是将树结构压平，使得子节点指针均指向根节点，这样能够加快元素的查询操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Find(x)</span><br><span class="line">    if x.parent != x</span><br><span class="line">        x.parent := Find(x.parent)</span><br><span class="line">    return x.parent</span><br></pre></td></tr></table></figure><h3 id="路径减半"><a href="#路径减半" class="headerlink" title="路径减半"></a>路径减半</h3><p>其实现方式是将节点父指针指向祖父节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Find(x)</span><br><span class="line">    while x.parent != x</span><br><span class="line">        x.parent := x.parent.parent</span><br><span class="line">        x := x.parent</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure><p><strong>注意：此时根节点父指针应该指向自己</strong></p><h2 id="合并优化"><a href="#合并优化" class="headerlink" title="合并优化"></a>合并优化</h2><p>有两种方式可作用于子集合并操作，通过<code>size</code>或<code>rank</code>来优化</p><h3 id="union-by-rank"><a href="#union-by-rank" class="headerlink" title="union by rank"></a>union by rank</h3><p>秩（<code>rank</code>）优化作用于子集合并操作，总是将较短树附加到较高树的根上。因此，生成的树不比原始树高。在高度相等的情况下，生成的树才会比原始树高一个节点</p><p>在每个元素中再添加一个成员<code>rank</code>。一个集合最初只有一个元素，所以秩为零</p><ul><li>如果两个集合具有相同的秩，任选其中一个作为根节点，结果集的秩加<code>1</code></li><li>如果两个集合具有不同的秩，较大<code>rank</code>值的子集作为根节点，结果集的秩不变</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Union(x, y)</span><br><span class="line">    xRoot := Find(x)</span><br><span class="line">    yRoot := Find(y)</span><br><span class="line"></span><br><span class="line">    // x and y are already in the same set</span><br><span class="line">    if xRoot == yRoot            </span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    // x and y are not in same set, so we merge them</span><br><span class="line">    if xRoot.rank &lt; yRoot.rank</span><br><span class="line">        xRoot, yRoot := yRoot, xRoot // swap xRoot and yRoot</span><br><span class="line">    // merge yRoot into xRoot</span><br><span class="line">    yRoot.parent := xRoot</span><br><span class="line">    if xRoot.rank == yRoot.rank:</span><br><span class="line">        xRoot.rank := xRoot.rank + 1</span><br></pre></td></tr></table></figure><h3 id="union-by-size"><a href="#union-by-size" class="headerlink" title="union by size"></a>union by size</h3><p>大小（<code>size</code>）优化的原理和<code>rank</code>优化类似，通过新成员<code>size</code>保存每个子集的元素个数。每次都选择较大<code>size</code>的子集作为根节点，并加上另一个子集的<code>size</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Union(x, y)</span><br><span class="line">    xRoot := Find(x)</span><br><span class="line">    yRoot := Find(y)</span><br><span class="line"></span><br><span class="line">    // x and y are already in the same set</span><br><span class="line">    if xRoot == yRoot            </span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    // x and y are not in same set, so we merge them</span><br><span class="line">    if xRoot.size &lt; yRoot.size</span><br><span class="line">        xRoot, yRoot := yRoot, xRoot // swap xRoot and yRoot</span><br><span class="line"></span><br><span class="line">    // merge yRoot into xRoot</span><br><span class="line">    yRoot.parent := xRoot</span><br><span class="line">    xRoot.size := xRoot.size + yRoot.size</span><br></pre></td></tr></table></figure><h2 id="类实现"><a href="#类实现" class="headerlink" title="类实现"></a>类实现</h2><p>下面创建类来实现并查集，通过路径压缩和<code>rank</code>合并来优化</p><ul><li>新建结构体<code>disjoint_set_element</code>，保存父指针和<code>rank</code></li><li>新建类<code>DisjointSet</code>，保存元素数组，实现查找和合并操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Created by zj on 19-10-31.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#ifndef CPLUSPLUS_DISJOINSET_H</span><br><span class="line">#define CPLUSPLUS_DISJOINSET_H</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">typedef struct disjoint_set_element &#123;</span><br><span class="line">    int parentPoint;</span><br><span class="line">    int rank;</span><br><span class="line">&#125; ds_element;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DisjointSet &#123;</span><br><span class="line">public:</span><br><span class="line">    DisjointSet(const int num);</span><br><span class="line"></span><br><span class="line">    ~DisjointSet();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 利用路径压缩优化</span><br><span class="line">     * @param x 起始节点</span><br><span class="line">     * @return 根节点</span><br><span class="line">     */</span><br><span class="line">    int find(int x);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 子集合并，利用rank进行优化</span><br><span class="line">     * @param x 根节点</span><br><span class="line">     * @param y 根节点</span><br><span class="line">     * @return 连接成功，返回true；连接失败或者原节点在同一个子集中，返回false</span><br><span class="line">     */</span><br><span class="line">    bool join(int x, int y);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回集合数</span><br><span class="line">     */</span><br><span class="line">    int getSetNum() &#123;</span><br><span class="line">        return this-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ds_element *elements;</span><br><span class="line">    // 子集数</span><br><span class="line">    int num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif //CPLUSPLUS_DISJOINSET_H</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Created by zj on 19-10-31.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;DisjointSet.h&quot;</span><br><span class="line"></span><br><span class="line">DisjointSet::DisjointSet(const int num) &#123;</span><br><span class="line">    elements = new ds_element[num];</span><br><span class="line">    this-&gt;num = num;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">        elements[i].rank = 0;</span><br><span class="line">        elements[i].parentPoint = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisjointSet::~DisjointSet() &#123;</span><br><span class="line">    delete[] elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DisjointSet::find(int x) &#123;</span><br><span class="line">    if (elements[x].parentPoint != x) &#123;</span><br><span class="line">        elements[x].parentPoint = find(elements[x].parentPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return elements[x].parentPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool DisjointSet::join(int x, int y) &#123;</span><br><span class="line">    if (x == y) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 保证节点x的rank大于等于节点y</span><br><span class="line">    if (elements[x].rank &lt; elements[y].rank) &#123;</span><br><span class="line">        int tmp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elements[y].parentPoint = x;</span><br><span class="line">    if (elements[x].rank == elements[y].rank) &#123;</span><br><span class="line">        elements[x].rank += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this-&gt;num--;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal算法实现"><a href="#Kruskal算法实现" class="headerlink" title="Kruskal算法实现"></a>Kruskal算法实现</h2><p>通过上节定义的并查集完成<code>Kruskal</code>算法，分别通过邻接矩阵和邻接表实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void AdjacencyTableUndirectedGraph::MiniSpanTree_Kruskal(GraphAdjList G) &#123;</span><br><span class="line">    int i, j, k, n, m;</span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    std::array&lt;Edge, MAXEDGE&gt; edges = &#123;&#125;;</span><br><span class="line">    DisjointSet disjointSet(G.numVertexes);</span><br><span class="line"></span><br><span class="line">    // 将边集赋值给edges</span><br><span class="line">    k = 0;</span><br><span class="line">    for (i = 0; i &lt; G.numVertexes; i++) &#123;</span><br><span class="line">        e = G.adjList[i].firstEdge;</span><br><span class="line"></span><br><span class="line">        while (e != nullptr) &#123;</span><br><span class="line">            if (e-&gt;adjvex &gt; i) &#123;</span><br><span class="line">                Edge edge;</span><br><span class="line">                edge.begin = i;</span><br><span class="line">                edge.end = e-&gt;adjvex;</span><br><span class="line">                edge.weight = e-&gt;weight;</span><br><span class="line"></span><br><span class="line">                edges[k] = edge;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            e = e-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 按权值升序排序</span><br><span class="line">    std::sort(edges.begin(), edges.begin() + G.numEdges, less_second);</span><br><span class="line"></span><br><span class="line">    int weight = 0;</span><br><span class="line">    // 升序遍历</span><br><span class="line">    for (i = 0; i &lt; G.numEdges; i++) &#123;</span><br><span class="line">        n = disjointSet.find(edges[i].begin);</span><br><span class="line">        m = disjointSet.find(edges[i].end);</span><br><span class="line">        if (disjointSet.join(n, m)) &#123;</span><br><span class="line">            printf(&quot;(%d, %d) %d\n&quot;, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">            weight += edges[i].weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;MST权值和为：&quot; &lt;&lt; weight &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool AdjacencyTableUndirectedGraph::less_second(Edge x, Edge y) &#123;</span><br><span class="line">    return x.weight &lt; y.weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码参考：<a href="https://github.com/zjZSTU/GraphLib" target="_blank" rel="noopener">zjZSTU/GraphLib</a></p></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';"> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/images/wechatpay.jpg" alt="zhujian 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/images/alipay.jpg" alt="zhujian 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zhujian</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zhujian.tech/posts/3eedae4a.html" title="[数据结构][图算法]并查集">https://www.zhujian.tech/posts/3eedae4a.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/c/" rel="tag"># c++</a> <a href="/tags/disjoint-set/" rel="tag"># 并查集</a> <a href="/tags/kruskal/" rel="tag"># kruskal</a> <a href="/tags/adjacency-list/" rel="tag"># 邻接矩阵</a> <a href="/tags/adjacency-matrix/" rel="tag"># 邻接表</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/7c823af7.html" rel="next" title="[Jenkins][Nginx]反向代理"><i class="fa fa-chevron-left"></i> [Jenkins][Nginx]反向代理</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/posts/a4b1a6d9.html" rel="prev" title="基于图的图像分割-工程源码">基于图的图像分割-工程源码<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="gitalk-container"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现"><span class="nav-number">2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找优化"><span class="nav-number">3.</span> <span class="nav-text">查找优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#路径压缩"><span class="nav-number">3.1.</span> <span class="nav-text">路径压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路径减半"><span class="nav-number">3.2.</span> <span class="nav-text">路径减半</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并优化"><span class="nav-number">4.</span> <span class="nav-text">合并优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#union-by-rank"><span class="nav-number">4.1.</span> <span class="nav-text">union by rank</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union-by-size"><span class="nav-number">4.2.</span> <span class="nav-text">union by size</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类实现"><span class="nav-number">5.</span> <span class="nav-text">类实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kruskal算法实现"><span class="nav-number">6.</span> <span class="nav-text">Kruskal算法实现</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zhujian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">zhujian</p><div class="site-description" itemprop="description">one bite at a time</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">169</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">48</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">129</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="feed-link motion-element"><a href="/./atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zjZSTU" title="Github &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;zjZSTU" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> Github</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/u012005313" title="CSDN &amp;rarr; https:&#x2F;&#x2F;blog.csdn.net&#x2F;u012005313" rel="noopener" target="_blank"><i class="fa fa-fw fa-book"></i> CSDN</a></span><span class="links-of-author-item"><a href="/mailto:zjzstu@gmail.com" title="Gmail &amp;rarr; mailto:zjzstu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> Gmail</a></span><span class="links-of-author-item"><a href="/mailto:505169307@gmail.com" title="QQmail &amp;rarr; mailto:505169307@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> QQmail</a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://cloud.tencent.com/" title="https:&#x2F;&#x2F;cloud.tencent.com" rel="noopener" target="_blank">腾讯云</a></li><li class="links-of-blogroll-item"> <a href="https://www.aliyun.com/" title="https:&#x2F;&#x2F;www.aliyun.com" rel="noopener" target="_blank">阿里云</a></li><li class="links-of-blogroll-item"> <a href="https://developer.android.com/" title="https:&#x2F;&#x2F;developer.android.com&#x2F;" rel="noopener" target="_blank">Android Dev</a></li><li class="links-of-blogroll-item"> <a href="https://jenkins.io/" title="https:&#x2F;&#x2F;jenkins.io&#x2F;" rel="noopener" target="_blank">Jenkins</a></li><li class="links-of-blogroll-item"> <a href="http://cs231n.github.io/" title="http:&#x2F;&#x2F;cs231n.github.io&#x2F;" rel="noopener" target="_blank">cs231n</a></li><li class="links-of-blogroll-item"> <a href="https://pytorch.org/docs/stable/index.html" title="https:&#x2F;&#x2F;pytorch.org&#x2F;docs&#x2F;stable&#x2F;index.html" rel="noopener" target="_blank">pytorch</a></li><li class="links-of-blogroll-item"> <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" title="https:&#x2F;&#x2F;docs.docker.com&#x2F;install&#x2F;linux&#x2F;docker-ce&#x2F;ubuntu&#x2F;" rel="noopener" target="_blank">docker</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">zhujian</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">948k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">26:20</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-bar-chart-o"></i></span> <a href="https://tongji.baidu.com/web/27249108/overview/index?siteId=13647183" rel="noopener" target="_blank">百度统计</a></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0</div><div class="beian"> <a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备 19026415号</a> <span class="post-meta-divider">|</span> <img src="/images/beian_icon.png" style="display:inline-block;text-decoration:none;height:13px"> <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33011802001748" rel="noopener" target="_blank">浙公网安备 33011802001748号</a></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span> <span class="site-uv" title="总访客量">访客数：<span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="site-pv" title="总访问量">阅读量：<span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="17,63,61" opacity="1" zindex="-1" count="199" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script><script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '8f22595c6dd29c94467d',
      clientSecret: 'e66bd90ebb9aa66c562c753dec6c90ceecbd51f2',
      repo: 'guestbook',
      owner: 'zjZSTU',
      admin: ['zjZSTU'],
      id: '4121b966424bc756236bb54bac281795',
        language: '',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script></body></html>