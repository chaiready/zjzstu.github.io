<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="alternate" href="/./atom.xml" title="做一个幸福的人" type="application/atom+xml"><meta name="google-site-verification" content="Qr_3yqLtyErDFKHW7mE8PJz4qDUX-bf_fMLpSRckQe4"><meta name="baidu-site-verification" content="zOwIvKMV7f"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Roboto:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.5.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"搜索文章",hits_empty:"我们没有找到任何搜索结果: ${query}",hits_stats:"找到约${hits}条结果（用时${time}ms）"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet"><meta name="description" content="OpenCV在模块opencv_contrib中实现了基于图的图像分割算法，其实现和作者提供的工程源码略有差别"><meta name="keywords" content="c++,opencv,并查集,kruskal,基于图的图像分割"><meta property="og:type" content="article"><meta property="og:title" content="基于图的图像分割-OpenCV源码"><meta property="og:url" content="https:&#x2F;&#x2F;www.zhujian.tech&#x2F;posts&#x2F;18052054.html"><meta property="og:site_name" content="做一个幸福的人"><meta property="og:description" content="OpenCV在模块opencv_contrib中实现了基于图的图像分割算法，其实现和作者提供的工程源码略有差别"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https:&#x2F;&#x2F;www.zhujian.tech&#x2F;imgs&#x2F;基于图的图像分割-OpenCV源码&#x2F;beach.png"><meta property="og:image" content="https:&#x2F;&#x2F;www.zhujian.tech&#x2F;imgs&#x2F;基于图的图像分割-OpenCV源码&#x2F;beach_opencv.png"><meta property="og:image" content="https:&#x2F;&#x2F;www.zhujian.tech&#x2F;imgs&#x2F;基于图的图像分割-OpenCV源码&#x2F;beach_opencv2.png"><meta property="og:updated_time" content="2020-02-15T05:36:35.871Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https:&#x2F;&#x2F;www.zhujian.tech&#x2F;imgs&#x2F;基于图的图像分割-OpenCV源码&#x2F;beach.png"><link rel="canonical" href="https://www.zhujian.tech/posts/18052054.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>基于图的图像分割-OpenCV源码 | 做一个幸福的人</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?e677aac1ac69b8826b9cfecb4e72e107";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">做一个幸福的人</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">面朝大海，春暖花开</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签<span class="badge">129</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类<span class="badge">48</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档<span class="badge">169</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header> <a href="https://github.com/zjZSTU" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.zhujian.tech/posts/18052054.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="zhujian"><meta itemprop="description" content="one bite at a time"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="做一个幸福的人"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 基于图的图像分割-OpenCV源码</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-11-05 14:59:00" itemprop="dateCreated datePublished" datetime="2019-11-05T14:59:00+00:00">2019-11-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-02-15 05:36:35" itemprop="dateModified" datetime="2020-02-15T05:36:35+00:00">2020-02-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/image-process/" itemprop="url" rel="index"><span itemprop="name">图像处理</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/programming-language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/data-learning/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/programming/codebase/" itemprop="url" rel="index"><span itemprop="name">代码库</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/image-process/object-segmentation/" itemprop="url" rel="index"><span itemprop="name">目标分割</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/data-structure/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/data-structure/graph/" itemprop="url" rel="index"><span itemprop="name">图</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/data-structure/tree/" itemprop="url" rel="index"><span itemprop="name">树</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/data-structure/graph/minimum-spanning-tree/" itemprop="url" rel="index"><span itemprop="name">最小生成树</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>11k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>18 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p><code>OpenCV</code>在模块<code>opencv_contrib</code>中实现了基于图的图像分割算法，其实现和作者提供的工程源码略有差别</p><a id="more"></a><p>下面首先解析源码，然后通过示例验证分割效果</p><ul><li>官网参考文档：<a href="https://docs.opencv.org/4.0.1/dd/d19/classcv_1_1ximgproc_1_1segmentation_1_1GraphSegmentation.html" target="_blank" rel="noopener">cv::ximgproc::segmentation::GraphSegmentation Class Reference</a></li><li>头文件<code>segmentation.hpp - /path/to/include/opencv4/opencv2/ximgproc/segmentation.hpp</code></li><li>源文件<code>graphsegmentation.cpp - /path/to/opencv_contrib/modules/ximgproc/src/graphsegmentation.cpp</code></li><li>实现示例<code>graphsegmentation_demo.cpp - /path/to/opencv_contrib/modules/ximgproc/samples/graphsegmentation_demo.cpp</code></li></ul><p><code>OpenCV</code>源码比较复杂，抽取相应实现到<a href="https://github.com/zjZSTU/GraphLib/tree/master/cplusplus/samples/graphsegmentation" target="_blank" rel="noopener">GraphLib/cplusplus/samples/graphsegmentation</a></p><h2 id="命令空间"><a href="#命令空间" class="headerlink" title="命令空间"></a>命令空间</h2><p>算法位于命令空间<code>cv::ximgproc::segmentation</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace cv &#123;</span><br><span class="line">    namespace ximgproc &#123;</span><br><span class="line">        namespace segmentation &#123;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><code>OpenCV</code>实现了并查集操作，定义了并查集元素类<code>PointSetElement</code>以及并查集操作类<code>PointSet</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class PointSetElement &#123;</span><br><span class="line">    public:</span><br><span class="line">        int p;</span><br><span class="line">        int size;</span><br><span class="line"></span><br><span class="line">        PointSetElement() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        PointSetElement(int p_) &#123;</span><br><span class="line">            p = p_;</span><br><span class="line">            size = 1;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// An object to manage set of points, who can be fusionned</span><br><span class="line">class PointSet &#123;</span><br><span class="line">    public:</span><br><span class="line">        PointSet(int nb_elements_);</span><br><span class="line">        ~PointSet();</span><br><span class="line"></span><br><span class="line">        int nb_elements;</span><br><span class="line"></span><br><span class="line">        // Return the main point of the point&apos;s set</span><br><span class="line">        int getBasePoint(int p);</span><br><span class="line"></span><br><span class="line">        // Join two sets of points, based on their main point</span><br><span class="line">        void joinPoints(int p_a, int p_b);</span><br><span class="line"></span><br><span class="line">        // Return the set size of a set (based on the main point)</span><br><span class="line">        int size(unsigned int p) &#123; return mapping[p].size; &#125;</span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        PointSetElement* mapping;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于<code>PointSetElement</code>而言，定义了分量大小$size$以及当前像素点在最小生成树中的父指针$p$</p><p>对于<code>PointSet</code>而言，有两个成员和<code>3</code>个函数</p><ul><li><code>nb_elements</code>：分量个数</li><li><code>mapping</code>：点集元素指针</li><li><code>getBasePoint(int p)</code>：得到元素所属分量的根节点坐标</li><li><code>joinPoints(int p_a, int p_b)</code>：合并两个分量</li><li><code>size(unsigned int p)</code>：返回元素<code>p</code>所在分量个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PointSet::PointSet(int nb_elements_) &#123;</span><br><span class="line">    nb_elements = nb_elements_;</span><br><span class="line"></span><br><span class="line">    mapping = new PointSetElement[nb_elements];</span><br><span class="line"></span><br><span class="line">    for ( int i = 0; i &lt; nb_elements; i++) &#123;</span><br><span class="line">        mapping[i] = PointSetElement(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PointSet::~PointSet() &#123;</span><br><span class="line">    delete [] mapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int PointSet::getBasePoint( int p) &#123;</span><br><span class="line"></span><br><span class="line">        int base_p = p;</span><br><span class="line"></span><br><span class="line">    while (base_p != mapping[base_p].p) &#123;</span><br><span class="line">        base_p = mapping[base_p].p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Save mapping for faster acces later</span><br><span class="line">    mapping[p].p = base_p;</span><br><span class="line"></span><br><span class="line">    return base_p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PointSet::joinPoints(int p_a, int p_b) &#123;</span><br><span class="line"></span><br><span class="line">    // Always target smaller set, to avoid redirection in getBasePoint</span><br><span class="line">    if (mapping[p_a].size &lt; mapping[p_b].size)</span><br><span class="line">        swap(p_a, p_b);</span><br><span class="line"></span><br><span class="line">    mapping[p_b].p = p_a;</span><br><span class="line">    mapping[p_a].size += mapping[p_b].size;</span><br><span class="line"></span><br><span class="line">    nb_elements--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在构造函数中，通过输入的参数<code>nb_elements_</code>创建指针空间，初始化每个点集元素的父指针指向自身</li><li>函数<code>getBasePoint</code>查询根节点，使用了路径压缩进行优化</li><li>函数<code>joinPoints</code>合并两个分量，累加两个分量个数到根节点。与工程实现不同的是，这里比较<code>size</code>大小进行合并</li></ul><h2 id="边"><a href="#边" class="headerlink" title="边"></a>边</h2><p>定义类<code>Edge</code>保存边信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Edge &#123;</span><br><span class="line">    public:</span><br><span class="line">        int from;</span><br><span class="line">        int to;</span><br><span class="line">        float weight;</span><br><span class="line"></span><br><span class="line">        bool operator &lt;(const Edge&amp; e) const &#123;</span><br><span class="line">            return weight &lt; e.weight;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含两个顶点坐标以及边权重，同时重写比较函数，可作用于边集排序</p><h2 id="图分割算法"><a href="#图分割算法" class="headerlink" title="图分割算法"></a>图分割算法</h2><p><code>OpenCV</code>定义了一个图分割算法声明类<code>GraphSegemntation</code>以及一个图分割算法实现类<code>GraphSegmentationImpl</code></p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>图分割算法声明类<code>GraphSegmentation</code>位于<code>segmentation.hpp</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class CV_EXPORTS_W GraphSegmentation : public Algorithm &#123;</span><br><span class="line">    public:</span><br><span class="line">        /** @brief Segment an image and store output in dst</span><br><span class="line">            @param src The input image. Any number of channel (1 (Eg: Gray), 3 (Eg: RGB), 4 (Eg: RGB-D)) can be provided</span><br><span class="line">            @param dst The output segmentation. It&apos;s a CV_32SC1 Mat with the same number of cols and rows as input image, with an unique, sequential, id for each pixel.</span><br><span class="line">        */</span><br><span class="line">        CV_WRAP virtual void processImage(InputArray src, OutputArray dst) = 0;</span><br><span class="line"></span><br><span class="line">        CV_WRAP virtual void setSigma(double sigma) = 0;</span><br><span class="line">        CV_WRAP virtual double getSigma() = 0;</span><br><span class="line"></span><br><span class="line">        CV_WRAP virtual void setK(float k) = 0;</span><br><span class="line">        CV_WRAP virtual float getK() = 0;</span><br><span class="line"></span><br><span class="line">        CV_WRAP virtual void setMinSize(int min_size) = 0;</span><br><span class="line">        CV_WRAP virtual int getMinSize() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** @brief Creates a graph based segmentor</span><br><span class="line">    @param sigma The sigma parameter, used to smooth image</span><br><span class="line">    @param k The k parameter of the algorythm</span><br><span class="line">    @param min_size The minimum size of segments</span><br><span class="line">    */</span><br><span class="line">CV_EXPORTS_W Ptr&lt;GraphSegmentation&gt; createGraphSegmentation(double sigma=0.5, float k=300, int min_size=100);</span><br></pre></td></tr></table></figure><p>声明了对外提供的接口，同时提供了创建图分割类对象的辅助函数<code>createGraphSegmentation</code></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>图分割算法实现类<code>GraphSegmentationImpl</code>位于<code>segmentation.hpp</code>，其继承了接口类<code>GraphSegmentation</code>并实现了分割算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class GraphSegmentationImpl : public GraphSegmentation &#123;</span><br><span class="line">    public:</span><br><span class="line">        GraphSegmentationImpl() &#123;</span><br><span class="line">            sigma = 0.5;</span><br><span class="line">            k = 300;</span><br><span class="line">            min_size = 100;</span><br><span class="line">            name_ = &quot;GraphSegmentation&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~GraphSegmentationImpl() CV_OVERRIDE &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        virtual void processImage(InputArray src, OutputArray dst) CV_OVERRIDE;</span><br><span class="line"></span><br><span class="line">        virtual void setSigma(double sigma_) CV_OVERRIDE &#123; if (sigma_ &lt;= 0) &#123; sigma_ = 0.001; &#125; sigma = sigma_; &#125;</span><br><span class="line">        virtual double getSigma() CV_OVERRIDE &#123; return sigma; &#125;</span><br><span class="line"></span><br><span class="line">        virtual void setK(float k_) CV_OVERRIDE &#123; k = k_; &#125;</span><br><span class="line">        virtual float getK() CV_OVERRIDE &#123; return k; &#125;</span><br><span class="line"></span><br><span class="line">        virtual void setMinSize(int min_size_) CV_OVERRIDE &#123; min_size = min_size_; &#125;</span><br><span class="line">        virtual int getMinSize() CV_OVERRIDE &#123; return min_size; &#125;</span><br><span class="line"></span><br><span class="line">        virtual void write(FileStorage&amp; fs) const CV_OVERRIDE &#123;</span><br><span class="line">            fs &lt;&lt; &quot;name&quot; &lt;&lt; name_</span><br><span class="line">            &lt;&lt; &quot;sigma&quot; &lt;&lt; sigma</span><br><span class="line">            &lt;&lt; &quot;k&quot; &lt;&lt; k</span><br><span class="line">            &lt;&lt; &quot;min_size&quot; &lt;&lt; (int)min_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtual void read(const FileNode&amp; fn) CV_OVERRIDE &#123;</span><br><span class="line">            CV_Assert( (String)fn[&quot;name&quot;] == name_ );</span><br><span class="line"></span><br><span class="line">            sigma = (double)fn[&quot;sigma&quot;];</span><br><span class="line">            k = (float)fn[&quot;k&quot;];</span><br><span class="line">            min_size = (int)(int)fn[&quot;min_size&quot;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        double sigma;</span><br><span class="line">        float k;</span><br><span class="line">        int min_size;</span><br><span class="line">        String name_;</span><br><span class="line"></span><br><span class="line">        // Pre-filter the image</span><br><span class="line">        void filter(const Mat &amp;img, Mat &amp;img_filtered);</span><br><span class="line"></span><br><span class="line">        // Build the graph between each pixels</span><br><span class="line">        void buildGraph(Edge **edges, int &amp;nb_edges, const Mat &amp;img_filtered);</span><br><span class="line"></span><br><span class="line">        // Segment the graph</span><br><span class="line">        void segmentGraph(Edge * edges, const int &amp;nb_edges, const Mat &amp; img_filtered, PointSet **es);</span><br><span class="line"></span><br><span class="line">        // Remove areas too small</span><br><span class="line">        void filterSmallAreas(Edge *edges, const int &amp;nb_edges, PointSet *es);</span><br><span class="line"></span><br><span class="line">        // Map the segemented graph to a Mat with uniques, sequentials ids</span><br><span class="line">        void finalMapping(PointSet *es, Mat &amp;output);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>public</code>函数包括</p><ul><li><code>processImage</code>：图像分割</li></ul><p><code>private</code>函数包括：</p><ul><li><code>filter</code>：高斯滤波</li><li><code>buildgraph</code>：创建边集</li><li><code>segmentGraph</code>：<code>Kruskal</code>算法得到最小生成树</li><li><code>filterSmallAreas</code>：合并小分量</li><li><code>finalMapping</code>：创建输出图</li></ul><p>另外<code>createGraphSegmentation</code>创建了分割类对象</p><h4 id="createGraphSegmentation"><a href="#createGraphSegmentation" class="headerlink" title="createGraphSegmentation"></a>createGraphSegmentation</h4><p>创建类对象，赋值高斯滤波参数<code>sigma</code>，阈值函数参数<code>k</code>，最小分量大小<code>min_size</code>，最后返回对象指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ptr&lt;GraphSegmentation&gt; createGraphSegmentation(double sigma, float k, int min_size) &#123;</span><br><span class="line"></span><br><span class="line">    Ptr&lt;GraphSegmentation&gt; graphseg = makePtr&lt;GraphSegmentationImpl&gt;();</span><br><span class="line"></span><br><span class="line">    graphseg-&gt;setSigma(sigma);</span><br><span class="line">    graphseg-&gt;setK(k);</span><br><span class="line">    graphseg-&gt;setMinSize(min_size);</span><br><span class="line"></span><br><span class="line">    return graphseg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>首先将输入图像转换成浮点类型，再调用高斯滤波函数<code>GaussianBlur</code>进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void GraphSegmentationImpl::filter(const Mat &amp;img, Mat &amp;img_filtered) &#123;</span><br><span class="line"></span><br><span class="line">    Mat img_converted;</span><br><span class="line"></span><br><span class="line">    // Switch to float</span><br><span class="line">    img.convertTo(img_converted, CV_32F);</span><br><span class="line"></span><br><span class="line">    // Apply gaussian filter</span><br><span class="line">    GaussianBlur(img_converted, img_filtered, Size(0, 0), sigma, sigma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入卷积核大小为$Size(0,0)$，参考<a href="https://www.zhujian.tech/posts/80b530f2.html">getGaussianKernel</a>，表示根据<code>sigma</code>值计算卷积核大小</p><h4 id="buildgraph"><a href="#buildgraph" class="headerlink" title="buildgraph"></a>buildgraph</h4><p>从左到右，从上到下的遍历像素点，计算当前顶点和<strong>上/下/左/右</strong>顶点的边</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int delta = -1; delta &lt;= 1; delta += 2) &#123;</span><br><span class="line">    for (int delta_j = 0, delta_i = 1; delta_j &lt;= 1; delta_j++ || delta_i--) &#123;</span><br><span class="line"></span><br><span class="line">        int i2 = i + delta * delta_i;</span><br><span class="line">        int j2 = j + delta * delta_j;</span><br></pre></td></tr></table></figure><p><code>i2/j2</code>取值为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i2 = -1 j2 = 0</span><br><span class="line">i2 = 0 j2 = -1</span><br><span class="line">i2 = 1 j2 = 0</span><br><span class="line">i2 = 0 j2 = 1</span><br></pre></td></tr></table></figure><p>边权重通过计算相邻像素点之间的$L2$距离获得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ( int channel = 0; channel &lt; nb_channels; channel++) &#123;</span><br><span class="line">    tmp_total += pow(p[j * nb_channels + channel] - p2[j2 * nb_channels + channel], 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建的边集会出现重复边的情况（<em>对无向图而言，虽然通过属性<code>from/to</code>明确了初始点和终止点</em>），不过在后续操作中都会使用到</p><h4 id="segmentGraph"><a href="#segmentGraph" class="headerlink" title="segmentGraph"></a>segmentGraph</h4><p>通过<code>Kruskal</code>算法实现分量的合并。首先进行边集排序，类<code>Edge</code>重写了比较函数，所以按权值升序排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::sort(edges, edges + nb_edges);</span><br></pre></td></tr></table></figure><p>然后创建并查集类<code>PointSet</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*es = new PointSet(img_filtered.cols * img_filtered.rows);</span><br></pre></td></tr></table></figure><p>并设置阈值函数，初始时每个分量个数为<code>1</code>，所以阈值大小为<code>k</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float* thresholds = new float[total_points];</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; total_points; i++)</span><br><span class="line">    thresholds[i] = k;</span><br></pre></td></tr></table></figure><p>遍历所有边，判断两个顶点是否位于同一分量。如果不是，判断是否满足边界条件。如果不是，合并两分量，更新阈值并设置边权重为<code>0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for ( int i = 0; i &lt; nb_edges; i++) &#123;</span><br><span class="line">    int p_a = (*es)-&gt;getBasePoint(edges[i].from);</span><br><span class="line">    int p_b = (*es)-&gt;getBasePoint(edges[i].to);</span><br><span class="line"></span><br><span class="line">    if (p_a != p_b) &#123;</span><br><span class="line">        if (edges[i].weight &lt;= thresholds[p_a] &amp;&amp; edges[i].weight &lt;= thresholds[p_b]) &#123;</span><br><span class="line">            (*es)-&gt;joinPoints(p_a, p_b);</span><br><span class="line">            p_a = (*es)-&gt;getBasePoint(p_a);</span><br><span class="line">            thresholds[p_a] = edges[i].weight + k / (*es)-&gt;size(p_a);</span><br><span class="line"></span><br><span class="line">            edges[i].weight = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>由于边集存在重复边的情况，所以将已使用的边权值设置为<code>0</code>之后，还有另一条相同的无向边存在</em></p><h4 id="filterSmallAreas"><a href="#filterSmallAreas" class="headerlink" title="filterSmallAreas"></a>filterSmallAreas</h4><p>再次遍历所有边，合并小分量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void GraphSegmentationImpl::filterSmallAreas(Edge *edges, const int &amp;nb_edges, PointSet *es) &#123;</span><br><span class="line">    for ( int i = 0; i &lt; nb_edges; i++) &#123;</span><br><span class="line">        if (edges[i].weight &gt; 0) &#123;</span><br><span class="line">            int p_a = es-&gt;getBasePoint(edges[i].from);</span><br><span class="line">            int p_b = es-&gt;getBasePoint(edges[i].to);</span><br><span class="line"></span><br><span class="line">            if (p_a != p_b &amp;&amp; (es-&gt;size(p_a) &lt; min_size || es-&gt;size(p_b) &lt; min_size)) &#123;</span><br><span class="line">                es-&gt;joinPoints(p_a, p_b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finalMapping"><a href="#finalMapping" class="headerlink" title="finalMapping"></a>finalMapping</h4><p>本函数作用于最后的不同分量颜色设置，输入参数为合并操作后的点集<code>PointSet *es</code>以及单通道图像<code>Mat &amp;output</code>。同一分量的像素点赋值同一个值，像素值从<code>0</code>开始递增</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;opencv2/ximgproc/segmentation.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui.hpp&quot;</span><br><span class="line">#include &quot;opencv2/core.hpp&quot;</span><br><span class="line">#include &quot;opencv2/imgproc.hpp&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace cv::ximgproc::segmentation;</span><br><span class="line"></span><br><span class="line">Scalar hsv_to_rgb(Scalar);</span><br><span class="line"></span><br><span class="line">Scalar color_mapping(int);</span><br><span class="line"></span><br><span class="line">static void help() &#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl &lt;&lt;</span><br><span class="line">              &quot;A program demonstrating the use and capabilities of a particular graph based image&quot; &lt;&lt; std::endl &lt;&lt;</span><br><span class="line">              &quot;segmentation algorithm described in P. Felzenszwalb, D. Huttenlocher,&quot; &lt;&lt; std::endl &lt;&lt;</span><br><span class="line">              &quot;             \&quot;Efficient Graph-Based Image Segmentation\&quot;&quot; &lt;&lt; std::endl &lt;&lt;</span><br><span class="line">              &quot;International Journal of Computer Vision, Vol. 59, No. 2, September 2004&quot; &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt;</span><br><span class="line">              &quot;Usage:&quot; &lt;&lt; std::endl &lt;&lt;</span><br><span class="line">              &quot;./graphsegmentation_demo input_image output_image [simga=0.5] [k=300] [min_size=100]&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Scalar hsv_to_rgb(Scalar c) &#123;</span><br><span class="line">    Mat in(1, 1, CV_32FC3);</span><br><span class="line">    Mat out(1, 1, CV_32FC3);</span><br><span class="line"></span><br><span class="line">    float *p = in.ptr&lt;float&gt;(0);</span><br><span class="line">    p[0] = (float) c[0] * 360.0f;</span><br><span class="line">    p[1] = (float) c[1];</span><br><span class="line">    p[2] = (float) c[2];</span><br><span class="line"></span><br><span class="line">    cvtColor(in, out, COLOR_HSV2RGB);</span><br><span class="line"></span><br><span class="line">    Scalar t;</span><br><span class="line">    Vec3f p2 = out.at&lt;Vec3f&gt;(0, 0);</span><br><span class="line">    t[0] = (int) (p2[0] * 255);</span><br><span class="line">    t[1] = (int) (p2[1] * 255);</span><br><span class="line">    t[2] = (int) (p2[2] * 255);</span><br><span class="line"></span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Scalar color_mapping(int segment_id) &#123;</span><br><span class="line">    double base = (double) (segment_id) * 0.618033988749895 + 0.24443434;</span><br><span class="line"></span><br><span class="line">    return hsv_to_rgb(Scalar(fmod(base, 1.2), 0.95, 0.80));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    if (argc &lt; 2 || argc &gt; 6) &#123;</span><br><span class="line">        help();</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ptr&lt;GraphSegmentation&gt; gs = createGraphSegmentation();</span><br><span class="line">    if (argc &gt; 3)</span><br><span class="line">        gs-&gt;setSigma(atof(argv[3]));</span><br><span class="line">    if (argc &gt; 4)</span><br><span class="line">        gs-&gt;setK((float) atoi(argv[4]));</span><br><span class="line">    if (argc &gt; 5)</span><br><span class="line">        gs-&gt;setMinSize(atoi(argv[5]));</span><br><span class="line">    if (!gs) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;Failed to create GraphSegmentation Algorithm.&quot; &lt;&lt; std::endl;</span><br><span class="line">        return -2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat input, output, output_image;</span><br><span class="line">    input = imread(argv[1]);</span><br><span class="line">    if (!input.data) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;Failed to load input image&quot; &lt;&lt; std::endl;</span><br><span class="line">        return -3;</span><br><span class="line">    &#125;</span><br><span class="line">    gs-&gt;processImage(input, output);</span><br><span class="line"></span><br><span class="line">    double min, max;</span><br><span class="line">    minMaxLoc(output, &amp;min, &amp;max);</span><br><span class="line"></span><br><span class="line">    int nb_segs = (int) max + 1;</span><br><span class="line">    std::cout &lt;&lt; nb_segs &lt;&lt; &quot; segments&quot; &lt;&lt; std::endl;</span><br><span class="line">    output_image = Mat::zeros(output.rows, output.cols, CV_8UC3);</span><br><span class="line"></span><br><span class="line">    uint *p;</span><br><span class="line">    uchar *p2;</span><br><span class="line">    for (int i = 0; i &lt; output.rows; i++) &#123;</span><br><span class="line">        p = output.ptr&lt;uint&gt;(i);</span><br><span class="line">        p2 = output_image.ptr&lt;uchar&gt;(i);</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; output.cols; j++) &#123;</span><br><span class="line">            Scalar color = color_mapping(p[j]);</span><br><span class="line">            p2[j * 3] = (uchar) color[0];</span><br><span class="line">            p2[j * 3 + 1] = (uchar) color[1];</span><br><span class="line">            p2[j * 3 + 2] = (uchar) color[2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    imwrite(argv[2], output_image);</span><br><span class="line">    std::cout &lt;&lt; &quot;Image written to &quot; &lt;&lt; argv[2] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先解析命令行参数，创建图像分割类对象并初始化参数</p><p>然后图像分割函数进行基于图的图像分割，输出单通道灰度图像</p><p>最后将创建<code>3</code>通道图像并赋值，同一分量的像素点设置相同的值。与论文提供的实现不同，为了使得分量间的颜色更加有区别，进行<code>HSV</code>颜色空间和<code>RGB</code>颜色空间的转换</p><p><img src="/imgs/基于图的图像分割-OpenCV源码/beach.png" alt></p><p><code>sigma=0.5, k=500, min_size=50</code></p><p><img src="/imgs/基于图的图像分割-OpenCV源码/beach_opencv.png" alt></p><p><code>sigma=0.5, k=300, min_size=100</code></p><p><img src="/imgs/基于图的图像分割-OpenCV源码/beach_opencv2.png" alt></p></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div> <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';"> 打赏</button><div id="qr" style="display:none"><div style="display:inline-block"> <img src="/images/wechatpay.jpg" alt="zhujian 微信支付"><p>微信支付</p></div><div style="display:inline-block"> <img src="/images/alipay.jpg" alt="zhujian 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> zhujian</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.zhujian.tech/posts/18052054.html" title="基于图的图像分割-OpenCV源码">https://www.zhujian.tech/posts/18052054.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/c/" rel="tag"># c++</a> <a href="/tags/opencv/" rel="tag"># opencv</a> <a href="/tags/disjoint-set/" rel="tag"># 并查集</a> <a href="/tags/kruskal/" rel="tag"># kruskal</a> <a href="/tags/Graph-Based-Image-Segmentation/" rel="tag"># 基于图的图像分割</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/a4b1a6d9.html" rel="next" title="基于图的图像分割-工程源码"><i class="fa fa-chevron-left"></i> 基于图的图像分割-工程源码</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/posts/1cb6a408.html" rel="prev" title="[译]作用于目标识别的选择性搜索">[译]作用于目标识别的选择性搜索<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="gitalk-container"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#命令空间"><span class="nav-number">1.</span> <span class="nav-text">命令空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并查集"><span class="nav-number">2.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#边"><span class="nav-number">3.</span> <span class="nav-text">边</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图分割算法"><span class="nav-number">4.</span> <span class="nav-text">图分割算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明"><span class="nav-number">4.1.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">4.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#createGraphSegmentation"><span class="nav-number">4.2.1.</span> <span class="nav-text">createGraphSegmentation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filter"><span class="nav-number">4.2.2.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#buildgraph"><span class="nav-number">4.2.3.</span> <span class="nav-text">buildgraph</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#segmentGraph"><span class="nav-number">4.2.4.</span> <span class="nav-text">segmentGraph</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filterSmallAreas"><span class="nav-number">4.2.5.</span> <span class="nav-text">filterSmallAreas</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finalMapping"><span class="nav-number">4.2.6.</span> <span class="nav-text">finalMapping</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例"><span class="nav-number">5.</span> <span class="nav-text">示例</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="zhujian" src="/images/avatar.png"><p class="site-author-name" itemprop="name">zhujian</p><div class="site-description" itemprop="description">one bite at a time</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">169</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">48</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">129</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="feed-link motion-element"><a href="/./atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zjZSTU" title="Github &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;zjZSTU" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> Github</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/u012005313" title="CSDN &amp;rarr; https:&#x2F;&#x2F;blog.csdn.net&#x2F;u012005313" rel="noopener" target="_blank"><i class="fa fa-fw fa-book"></i> CSDN</a></span><span class="links-of-author-item"><a href="/mailto:zjzstu@gmail.com" title="Gmail &amp;rarr; mailto:zjzstu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> Gmail</a></span><span class="links-of-author-item"><a href="/mailto:505169307@gmail.com" title="QQmail &amp;rarr; mailto:505169307@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> QQmail</a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://cloud.tencent.com/" title="https:&#x2F;&#x2F;cloud.tencent.com" rel="noopener" target="_blank">腾讯云</a></li><li class="links-of-blogroll-item"> <a href="https://www.aliyun.com/" title="https:&#x2F;&#x2F;www.aliyun.com" rel="noopener" target="_blank">阿里云</a></li><li class="links-of-blogroll-item"> <a href="https://developer.android.com/" title="https:&#x2F;&#x2F;developer.android.com&#x2F;" rel="noopener" target="_blank">Android Dev</a></li><li class="links-of-blogroll-item"> <a href="https://jenkins.io/" title="https:&#x2F;&#x2F;jenkins.io&#x2F;" rel="noopener" target="_blank">Jenkins</a></li><li class="links-of-blogroll-item"> <a href="http://cs231n.github.io/" title="http:&#x2F;&#x2F;cs231n.github.io&#x2F;" rel="noopener" target="_blank">cs231n</a></li><li class="links-of-blogroll-item"> <a href="https://pytorch.org/docs/stable/index.html" title="https:&#x2F;&#x2F;pytorch.org&#x2F;docs&#x2F;stable&#x2F;index.html" rel="noopener" target="_blank">pytorch</a></li><li class="links-of-blogroll-item"> <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" title="https:&#x2F;&#x2F;docs.docker.com&#x2F;install&#x2F;linux&#x2F;docker-ce&#x2F;ubuntu&#x2F;" rel="noopener" target="_blank">docker</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">zhujian</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">948k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">26:20</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-bar-chart-o"></i></span> <a href="https://tongji.baidu.com/web/27249108/overview/index?siteId=13647183" rel="noopener" target="_blank">百度统计</a></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0</div><div class="beian"> <a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备 19026415号</a> <span class="post-meta-divider">|</span> <img src="/images/beian_icon.png" style="display:inline-block;text-decoration:none;height:13px"> <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33011802001748" rel="noopener" target="_blank">浙公网安备 33011802001748号</a></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span> <span class="site-uv" title="总访客量">访客数：<span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="site-pv" title="总访问量">阅读量：<span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="17,63,61" opacity="1" zindex="-1" count="199" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script><script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '8f22595c6dd29c94467d',
      clientSecret: 'e66bd90ebb9aa66c562c753dec6c90ceecbd51f2',
      repo: 'guestbook',
      owner: 'zjZSTU',
      admin: ['zjZSTU'],
      id: '8ed7175205d34ea2e0ff7c2a9c53c983',
        language: '',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script></body></html>